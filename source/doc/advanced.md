# 进阶篇

`ZMQ`的`socket`的生命周期：

1. 创建和销毁套接字
2. 配置和读取套接字选项
3. 为套接字建立连接
4. 发送和接收消息

## 使用套接字构建拓扑结构

在两个节点相互连接时，一个使用`bind()`，另一个使用`connect()`。一般来说，使用`bind()`的是服务端，绑定`socket`至端点，地址固定；使用`connect()`为服务端，连接`socket`至端点，地址不固定。端点是指某个广为人知的网络地址。

`ZMQ`连接和传统的`TCP`连接是有区别的，主要有：

- 使用多种协议，`inproc`（进程内）、`ipc`（进程间）、`tcp`、 `pgm`（广播）、`epgm`。
- 当客户端使用`connect()`时连接就已经建立了，并不要求该 端点已有某个服务使用`bind()`进行了绑定。
- 连接是异步的，并由一组消息队列做缓冲。
- 连接会表现出某种消息模式，这是由创建连接的套接字类型决定的。
- 一个套接字可以有多个输入和输出连接。
- `ZMQ`没有类似Python原生`socket`中的`accept()`的函数，当套接字绑定至端 点时它就自动开始接受连接了。

在现在很多架构都是使用了类似于`C/S（client/server）`的架构。相比于服务端，客户端的组件要更加动态。服务端的地址对于客户端来说，往往是可见的，反之则不然。在传统的网络连接中，如果先打开客户端，再打开服务端，那客户端势必会受到系统的报错信息，但是`ZMQ`的机制，却让我们自由的先后启动架构中任意一方的组件。

服务端节点可以仅使用一个套接字就能绑定至多个端点。也就是说，它能够使用不同的协议来建立连接：

```python
import zmq
context = zmq.Context()
socket = context.socket(zmq.PUB)

socket.bind('tcp://127.0.0.1:5555')
socket.bind('ipc://myserver.ipc')
```

当然，多次绑定同一个地址是不允许的，这样会报错：**`zmq.error.ZMQError: Address in use`**。

每当有客户端节点使用`connect()`连接至上述某个端点时，服务端就会自动创建连接。`ZMQ`没有对连接数量进行限制。此外，客户端节点也可以使用一个`socket`同时建立多个连接。大多数情况下，哪个节点充当服务端，哪个作为客户端，是网络架构层 面的内容，而非消息流问题。不过也有一些特殊情况（如失去连接后的 消息重发），同一种`socket`使用绑定和连接是会有一些不同的行为的。所以说，当在设计架构时，应该遵循**服务端是稳定的，客户端是灵活的**原则，就不太会出错。

`socket`是有类型的，`socket`类型定义了套接字的行为，它在发送和接收消息时的规则等。将不同种类的`socket`进行连接，如PUB-SUB组 合，这种组合称之为**发布-订阅**模式。

`socket`可以使用不同的方式连接，构建了`ZMQ`最基本的消息队列系统。在此基础之上，我们还可以在建立更为复杂的装置或是路由机制。`ZMQ`提供了一整台组件，可在网络架构中根据需求去组装使用。